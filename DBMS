Topics for DBMS

* what is database ?
    A database is an organised collection of structured information, or data, typically stored electronically in a computer system. 

* what is DBMS ?
    A dbms helps to store and manage data in database. It acts as an interface between the user and the database enabling users to efficiently create,read,update,delete data into database while enabling 
    data security,integrity and concurency.

* what is RDMS and what are its properties ?
    Relational database management systems is a database system that is based on a relational model where data is stored in tables(relations) linked by keys. It allows to efficiently store,retrieve and 
    manipulate the structured data using SQL.
    -----properties of RDMS (ACID)------  
    1) Atomicity: It ensures that all part of transactions are completed. If not transaction get rollback to its initial state maintaining data consistancy.
    2) Consistency: Ensures data transaction from one valid state another, maintaining data integrity.
    3) Isolation: Ensures transactions are executed independently without any interference.
    4) Durabiltiy: Ensures that once transaction get commited, it is permanently stored, even in case of failure.

* What are the types of database language ?
    1) Data defination language (DDL): used to define and manage database schema. (CREATE, ALTER, DROP)
    2) Data Manipulation language (DML):  used to retrieve and manipulate data within the database. (SELECT, INSERT, UPDATE, DELETE)
    3) Data Control language (DCL): used to control data in the database. (GRANT,REVOKE)
    4) Transaction control language (TCL): used to manage transactions in the database. (COMMIT,ROLLBACK,SAVEPOINT)

* what is ACID properties ?
    To ensure consistency in database, certain properties are followed by the transations occured in the system.
    refer Q3

* Difference between vertical and horizontal scaling ?
    vertical scaling:
        * Involves adding more resources (CPU,RAM,Storage) to a single node or server.
        * Easier to implement but had hardware limitations and single point of failure for a system.
        * Suitable for apllications with limited growth requirements.
    Horizontal scaling: 
        * Involves adding more servers or nodes to distribute the load.
        * Provides better fault tolerance and can hangle larger growth.
        * Complex to handle but can scale infinitly according to the demand.

* What is Sharding ? 
    Sharding is a database partitioning technique where a large database is split into smaller and manageble peices called shards. Each shard contains a subset of data and is stored in seperate server.
    * purpose: improves performance and scalability by distributing load accross multiple servers.
    * Type: can be based on range based sharding or hash based sharding.
        * range-based sharding 
            Data is partitioned in shards based on sharding keys. (ex. user with id: 1-1000 -> shard1, 1001-2000 -> shard2......)
            Easy to implement but can lead to uneven data distribution if data is not uniformly distributed.
        * Hash-based sharding 
            Data is distributed by applying hashing to sharding keys. (hash_func(user_id)%no_of_shards).
            provides even data distribution and balances load across shards, but may make range queries much difficult.
            Consistent hashing can also be used it continouly adding or deleting the shards in the distribution.
    * Benfefits: Reduces query load, increase read/write throughput, and provides fault tolerance.


* Indexing in database 
    As u know database stores the data in disk and data structure stores the data in RAM. So in disk data is stored in tracks and sectors. so intersection of both makes a block in disk.
    so lets say each block can store 512Bits of data and the block offset becomes 0 to 511. 
    Now comes the question how to get this data much faster. lets say we have a table of 100 records and each record take 128bits of data.
    no. of records in 1 bloak  = 4, total no. of blocks required = 25.
    so to get a record we need to search 25 blocks in a disk. we can reduce this time by introducing index table of id and a pointer to that block. now size of index row =  16bits.
    no. of blocks required ~ 4 as 512/16 = 32 rows in 1 block and 100/32 ~ 4.
    now searching becomes 4 + 1 = 5 block reduced from 25 to 5 blocks.
    we can also create sparse of indexing (multi level indexing) by introducing index table of index table when the data becomes huge. let say we have 1000 records than blocks = 250, index block becomes = 40.
    this searching is also expensive therefore introduce another index table of index table which stores pointer to the block not record.
    therefore now the index table key value will be 1,33,.... with value as the pointer of the block. so blocks required for this  ~ 2. so search = 2 + 1 + 1 becomes 4 block only.

* B trees and B+ trees
    It uses m-way search tree wit some rules and uses multi level indexing. watch abdul bari video.
    rules that b tree follow in m-way tree (m = no. of childeren) (k=no. of keys) and k = m-1
    1) no. of keys that a node will have = ceil(m/2) other than root node.
    2) root can have min 2 children.
    3) all the leaves are at same level. height = logm(n) where n is no of records and m =  max number of keys that a nodes can have.
    4) creation process is bottom up 
    difference between B tree and B+ tree is that in B+ tree all keys and their record pointer are stored in leave nodes and all leave nodes are connected through linked list. helps doing when we want
    data in range
    
