Topics for DBMS

* what is database ?
    A database is an organised collection of structured information, or data, typically stored electronically in a computer system. 

* what is DBMS ?
    A dbms helps to store and manage data in database. It acts as an interface between the user and the database enabling users to efficiently create,read,update,delete data into database while enabling 
    data security,integrity and concurency.

* what is RDMS and what are its properties ?
    Relational database management systems is a database system that is based on a relational model where data is stored in tables(relations) linked by keys. It allows to efficiently store,retrieve and 
    manipulate the structured data using SQL.
    -----properties of RDMS (ACID)------  
    1) Atomicity: It ensures that all part of transactions are completed. If not transaction get rollback to its initial state maintaining data consistancy.
    2) Consistency: Ensures data transaction from one valid state another, maintaining data integrity.
    3) Isolation: Ensures transactions are executed independently without any interference.
    4) Durabiltiy: Ensures that once transaction get commited, it is permanently stored, even in case of failure.

* What are the types of database language ?
    1) Data defination language (DDL): used to define and manage database schema. (CREATE, ALTER, DROP)
    2) Data Manipulation language (DML):  used to retrieve and manipulate data within the database. (SELECT, INSERT, UPDATE, DELETE)
    3) Data Control language (DCL): used to control data in the database. (GRANT,REVOKE)
    4) Transaction control language (TCL): used to manage transactions in the database. (COMMIT,ROLLBACK,SAVEPOINT)

* what is ACID properties ?
    To ensure consistency in database, certain properties are followed by the transations occured in the system.
    refer Q3

* Difference between vertical and horizontal scaling ?
    vertical scaling:
        * Involves adding more resources (CPU,RAM,Storage) to a single node or server.
        * Easier to implement but had hardware limitations and single point of failure for a system.
        * Suitable for apllications with limited growth requirements.
    Horizontal scaling: 
        * Involves adding more servers or nodes to distribute the load.
        * Provides better fault tolerance and can hangle larger growth.
        * Complex to handle but can scale infinitly according to the demand.

* What is Sharding ? 
    Sharding is a database partitioning technique where a large database is split into smaller and manageble peices called shards. Each shard contains a subset of data and is stored in seperate server.
    * purpose: improves performance and scalability by distributing load accross multiple servers.
    * Type: can be based on range based sharding or hash based sharding.
        * range-based sharding 
            Data is partitioned in shards based on sharding keys. (ex. user with id: 1-1000 -> shard1, 1001-2000 -> shard2......)
            Easy to implement but can lead to uneven data distribution if data is not uniformly distributed.
        * Hash-based sharding 
            Data is distributed by applying hashing to sharding keys. (hash_func(user_id)%no_of_shards).
            provides even data distribution and balances load across shards, but may make range queries much difficult.
            Consistent hashing can also be used it continouly adding or deleting the shards in the distribution.
    * Benfefits: Reduces query load, increase read/write throughput, and provides fault tolerance.

* Keys in DBMS ?
    keys are set of attributes, that can uniquely identify tuple/row/record in a relation/table.
    types of keys:
        * primary key: uniquely identifies each record in a table, must be unique and not NULL.
        * Foreign key: establishs a relation between table by refrencing the primary key of another table.
        * unique key: ensures that all values in a column or set of columns are unique accross the table. Can be null but only one null value is allowed if it is a single column key.
        * composite key: a primary key consists of 2 or more columns to uniquely identify the record.
        * candidate key: all the columns including primary key that can uniquiely identifies the record. One of the candidate key is a primary key.
        * Alternate key: a candidate key that is not selected as primary key.

* What are the types of relationships ?
    One-to-One(1:1):
        each record in one table is related to single record in another table and vice versa. ex. person table -- passport table
    One-to-many(1:n):
        single record in one table is related to multiple records in another table. person table -- order table
    many-to-may(n:n):   
        multiple record in one table is related to multiple records in another table. person table -- role table

* what is data Abstraction in DBMS ? what are its 3 levels ?
    Data abstraction refers to the process of hiding the underlying complexity of internal database and its structure from the user allowing them to interact with data without knowing its details.
    levels of Abstractions are:-
    * Physical(storage):
        lowest level of abstraction which defines how the data is actually stored in database. e.g, file storage, indexing etc.
    * logical(structure):
        the middle level of abstraction which defines what data is stored and its relationships among the data.
    * View(user perspective):
        the highest level of abstraction, provides only part of the database to the user and application.
    
* Indexing in database 
    As u know database stores the data in disk and data structure stores the data in RAM. So in disk data is stored in tracks and sectors. so intersection of both makes a block in disk.
    so lets say each block can store 512Bits of data and the block offset becomes 0 to 511. 
    Now comes the question how to get this data much faster. lets say we have a table of 100 records and each record take 128bits of data.
    no. of records in 1 bloak  = 4, total no. of blocks required = 25.
    so to get a record we need to search 25 blocks in a disk. we can reduce this time by introducing index table of id and a pointer to that block. now size of index row =  16bits.
    no. of blocks required ~ 4 as 512/16 = 32 rows in 1 block and 100/32 ~ 4.
    now searching becomes 4 + 1 = 5 block reduced from 25 to 5 blocks.
    we can also create sparse of indexing (multi level indexing) by introducing index table of index table when the data becomes huge. let say we have 1000 records than blocks = 250, index block becomes = 40.
    this searching is also expensive therefore introduce another index table of index table which stores pointer to the block not record.
    therefore now the index table key value will be 1,33,.... with value as the pointer of the block. so blocks required for this  ~ 2. so search = 2 + 1 + 1 becomes 4 block only.

* B trees and B+ trees
    It uses m-way search tree wit some rules and uses multi level indexing. watch abdul bari video.
    rules that b tree follow in m-way tree (m = no. of childeren) (k=no. of keys) and k = m-1
    1) no. of keys that a node will have = ceil(m/2) other than root node.
    2) root can have min 2 children.
    3) all the leaves are at same level. height = logm(n) where n is no of records and m =  max number of keys that a nodes can have.
    4) creation process is bottom up 
    difference between B tree and B+ tree is that in B+ tree all keys and their record pointer are stored in leave nodes and all leave nodes are connected through linked list. helps doing when we want
    data in range

* what is normalization ? and types of normalization ?
    It is a process of organizing data in database to reduce redunduncy by dividing a database into tables and defining relations between them to ensure that data is stored efficiently.
    Types of normalizations:
        * first normal form (1nf):
            elemeniate duplicate columns from the table. e.g, user,course1,course2 in a table to make user,course
        * second normal form (2nf):
            meets all requirements of 1nf. Ensuring non-key attributes are fully dependent on primary key.e.g, divide id,name,couse,instructor ---> id,name and id,course,instructor
        * third normal form (3nf):
            meets all requirements of 2nf. Ensuring non-key attributes ate only dependent on primary key.e.g, divide id,course,instructor ---> id,course and course,instructor.
        * Boyce-Codd Normal Form (BCNF):
            advance version of 3nf
    disadvantage of normalisation is that it increases complexity,performance overhead(joins),higher latency,maintanance overhead.

* what is denormalization ?
    Denormalization is a process of adding redunduncy in the database by combining tables or storing duplicate data to improve read performance. used to reduce number of joins
    benefits are:
        * improves read performance 
        * simplifies queries
    disadvantage:
        * needs more storage dure to redundancy
        * Risk of data Anomalies, can lead to data inconsistency since data is stored in different locations.
    when to use:
        * when read operation is more frequent than write

    
